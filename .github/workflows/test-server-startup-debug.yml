name: Test Server Startup (Debug Branch)

on:
  push:
    branches:
      - debug-hardcoded-secrets
  workflow_dispatch:
    inputs:
      wait_time:
        description: 'Seconds to wait for server startup'
        required: false
        default: '15'
        type: string

jobs:
  test-server-startup:
    name: Test on Python ${{ matrix.python-version }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: ['3.9', '3.10', '3.11']
    
    steps:
      - name: üì• Checkout debug-hardcoded-secrets branch
        uses: actions/checkout@v4
        with:
          ref: debug-hardcoded-secrets
      
      - name: üêç Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: üì¶ Install dependencies from requirements.txt
        run: |
          cd vm_server
          echo "===================================="
          echo "Installing dependencies..."
          echo "===================================="
          pip install --upgrade pip
          pip install -r requirements.txt
          echo ""
          echo "===================================="
          echo "Installed packages:"
          echo "===================================="
          pip list | grep -E '(fastmcp|uvicorn|starlette|httpx|aiofiles|dotenv)'
      
      - name: üîç Verify critical dependencies
        run: |
          echo "===================================="
          echo "Verifying critical imports..."
          echo "===================================="
          
          # Helper function to get version safely
          python << 'EOF'
          import sys
          
          def get_version(module_name):
              """Get version of a module, handling missing __version__ attribute."""
              try:
                  mod = __import__(module_name)
                  # Try __version__ first
                  if hasattr(mod, '__version__'):
                      return mod.__version__
                  # Fall back to importlib.metadata
                  try:
                      from importlib.metadata import version
                      return version(module_name)
                  except Exception:
                      # If all else fails, just confirm it imports
                      return "installed"
              except ImportError as e:
                  print(f"‚ùå {module_name}: NOT FOUND - {e}")
                  sys.exit(1)
          
          # Check each dependency
          packages = [
              ('fastmcp', 'fastmcp'),
              ('uvicorn', 'uvicorn'),
              ('starlette', 'starlette'),
              ('httpx', 'httpx'),
              ('aiofiles', 'aiofiles'),
          ]
          
          for display_name, module_name in packages:
              ver = get_version(module_name)
              print(f"‚úÖ {display_name}: {ver}")
          
          # Special case for python-dotenv
          try:
              from dotenv import load_dotenv
              print("‚úÖ python-dotenv: OK")
          except ImportError as e:
              print(f"‚ùå python-dotenv: NOT FOUND - {e}")
              sys.exit(1)
          
          print("\n‚úÖ All critical dependencies verified!")
          EOF
      
      - name: üöÄ Start server in background with MAXIMUM VERBOSITY
        run: |
          cd vm_server
          echo "===================================="
          echo "üîç STARTING SERVER WITH MAXIMUM DEBUG OUTPUT"
          echo "===================================="
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%N')"
          echo "Working directory: $(pwd)"
          echo "Python: $(which python)"
          echo "Python version: $(python --version)"
          echo ""
          
          echo "===================================="
          echo "üìù Creating startup wrapper script..."
          echo "===================================="
          
          # Create a wrapper script for maximum debugging
          cat > start_server.sh << 'WRAPPER_EOF'
          #!/bin/bash
          set -x  # Print commands as they execute
          
          echo "=========================================="
          echo "üöÄ SERVER STARTUP WRAPPER"
          echo "=========================================="
          echo "Start time: $(date '+%Y-%m-%d %H:%M:%S.%N')"
          echo "PID: $$"
          echo "Working directory: $(pwd)"
          echo ""
          
          echo "=========================================="
          echo "üîç Pre-startup checks..."
          echo "=========================================="
          echo "server.py exists: $(test -f server.py && echo 'YES' || echo 'NO')"
          echo "server.py size: $(stat -f%z server.py 2>/dev/null || stat -c%s server.py 2>/dev/null || echo 'unknown') bytes"
          echo "server.py permissions: $(ls -l server.py)"
          echo ""
          
          echo "=========================================="
          echo "üêç Starting Python with VERBOSE flags..."
          echo "=========================================="
          echo "Flags: -u (unbuffered) -v (verbose imports)"
          echo "Capturing both stdout and stderr"
          echo "Start time: $(date '+%Y-%m-%d %H:%M:%S.%N')"
          echo ""
          
          # Run Python with maximum verbosity
          # -u: unbuffered output (immediate)
          # -v: verbose import messages
          # 2>&1: capture both stdout and stderr
          python -u server.py 2>&1
          
          # Capture exit code
          EXIT_CODE=$?
          
          echo ""
          echo "=========================================="
          echo "üí• PYTHON PROCESS EXITED"
          echo "=========================================="
          echo "Exit time: $(date '+%Y-%m-%d %H:%M:%S.%N')"
          echo "Exit code: $EXIT_CODE"
          echo ""
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå SERVER FAILED TO START (exit code $EXIT_CODE)"
          else
            echo "‚úÖ SERVER EXITED CLEANLY (exit code 0)"
          fi
          
          exit $EXIT_CODE
          WRAPPER_EOF
          
          chmod +x start_server.sh
          
          echo "‚úÖ Wrapper script created"
          echo ""
          
          echo "===================================="
          echo "üèÉ Launching server in background..."
          echo "===================================="
          
          # Run wrapper in background, capturing ALL output
          nohup ./start_server.sh > server.log 2>&1 &
          SERVER_PID=$!
          
          echo "Server PID: $SERVER_PID"
          echo $SERVER_PID > server.pid
          
          echo ""
          echo "‚úÖ Server launch initiated"
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%N')"
      
      - name: ‚è≥ Wait for server startup with live monitoring
        run: |
          cd vm_server
          WAIT_TIME=${{ inputs.wait_time || '15' }}
          SERVER_PID=$(cat server.pid)
          
          echo "===================================="
          echo "‚è±Ô∏è  Monitoring server startup..."
          echo "===================================="
          echo "Wait time: ${WAIT_TIME} seconds"
          echo "Server PID: $SERVER_PID"
          echo "Start time: $(date '+%Y-%m-%d %H:%M:%S.%N')"
          echo ""
          
          # Monitor the server while waiting
          for i in $(seq 1 $WAIT_TIME); do
            # Check if process still exists
            if ! ps -p $SERVER_PID > /dev/null 2>&1; then
              echo ""
              echo "‚ùå Process $SERVER_PID exited early (after $i seconds)!"
              echo "Checking exit code..."
              
              # Get exit code if available (from wait)
              wait $SERVER_PID 2>/dev/null
              EXIT_CODE=$?
              echo "Exit code: $EXIT_CODE"
              break
            fi
            
            # Show progress and process info every 5 seconds
            if [ $((i % 5)) -eq 0 ]; then
              echo "[${i}s] Process status:"
              ps -o pid,ppid,stat,time,cmd -p $SERVER_PID 2>/dev/null || echo "  Process not found"
            else
              echo -n "."
            fi
            
            sleep 1
          done
          
          echo ""
          echo "Wait complete at: $(date '+%Y-%m-%d %H:%M:%S.%N')"
      
      - name: üîç Show server logs IMMEDIATELY (first look)
        if: always()
        run: |
          cd vm_server
          echo "===================================="
          echo "üìä INITIAL SERVER OUTPUT"
          echo "===================================="
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%N')"
          echo ""
          
          if [ -f server.log ]; then
            echo "Log file size: $(stat -f%z server.log 2>/dev/null || stat -c%s server.log 2>/dev/null || echo 'unknown') bytes"
            echo "Log file lines: $(wc -l < server.log)"
            echo ""
            echo "First 100 lines of output:"
            echo "----------------------------------------"
            head -n 100 server.log || cat server.log
            echo "----------------------------------------"
          else
            echo "‚ùå No server.log file found!"
          fi
      
      - name: ‚úÖ Check server process is running
        id: check_process
        run: |
          cd vm_server
          SERVER_PID=$(cat server.pid)
          
          echo "===================================="
          echo "üîç Process Status Check"
          echo "===================================="
          echo "Checking PID: $SERVER_PID"
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%N')"
          echo ""
          
          # Detailed process check
          if ps -p $SERVER_PID > /dev/null 2>&1; then
            echo "‚úÖ SUCCESS: Process $SERVER_PID is RUNNING!"
            echo ""
            echo "Process details:"
            ps -o pid,ppid,stat,time,vsz,rss,cmd -p $SERVER_PID
            echo ""
            echo "Process tree:"
            pstree -p $SERVER_PID 2>/dev/null || echo "(pstree not available)"
            echo ""
            echo "status=running" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "‚ùå FAILED: Process $SERVER_PID has EXITED!"
            echo ""
            
            # Try to get exit reason
            echo "Searching for exit information in logs..."
            if grep -q "Exit code:" server.log; then
              echo ""
              echo "Found exit code information:"
              grep -A 5 "Exit code:" server.log
            fi
            
            echo ""
            echo "status=exited" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: üìä Show COMPLETE server startup logs
        if: always()
        run: |
          cd vm_server
          echo "===================================="
          echo "üìú COMPLETE SERVER STARTUP LOGS"
          echo "===================================="
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%N')"
          echo ""
          
          if [ -f server.log ]; then
            echo "Log file size: $(stat -f%z server.log 2>/dev/null || stat -c%s server.log 2>/dev/null || echo 'unknown') bytes"
            echo "Log file lines: $(wc -l < server.log)"
            echo ""
            echo "===================================="
            echo "FULL LOG OUTPUT:"
            echo "===================================="
            cat server.log
            echo "===================================="
            echo "END OF LOG OUTPUT"
            echo "===================================="
          else
            echo "‚ùå No server.log file found!"
          fi
      
      - name: üîç Analyze server logs for errors
        if: always()
        run: |
          cd vm_server
          echo "===================================="
          echo "üî¨ Log Analysis"
          echo "===================================="
          
          if [ ! -f server.log ]; then
            echo "‚ùå No log file to analyze"
            exit 0
          fi
          
          echo ""
          echo "üìä Log Statistics:"
          echo "  Total lines: $(wc -l < server.log)"
          echo "  File size: $(stat -f%z server.log 2>/dev/null || stat -c%s server.log 2>/dev/null || echo 'unknown') bytes"
          echo ""
          
          # Check for startup milestones
          echo "üéØ Startup Milestones:"
          grep -q "DEBUG: Starting server imports" server.log && echo "  ‚úÖ Import phase started" || echo "  ‚ùå Import phase NOT reached"
          grep -q "DEBUG: All imports complete" server.log && echo "  ‚úÖ Imports completed" || echo "  ‚ùå Imports NOT completed"
          grep -q "DEBUG: Loading configuration" server.log && echo "  ‚úÖ Configuration loading started" || echo "  ‚ùå Configuration NOT started"
          grep -q "DEBUG: Configuration loaded" server.log && echo "  ‚úÖ Configuration loaded" || echo "  ‚ùå Configuration NOT loaded"
          grep -q "DEBUG: Registering tools" server.log && echo "  ‚úÖ Tool registration started" || echo "  ‚ùå Tool registration NOT started"
          grep -q "Tools registered successfully" server.log && echo "  ‚úÖ Tools registered" || echo "  ‚ùå Tools NOT registered"
          grep -q "DEBUG: Starting mcp.run" server.log && echo "  ‚úÖ Server run started" || echo "  ‚ùå Server run NOT started"
          grep -q "Uvicorn running on" server.log && echo "  ‚úÖ Uvicorn started" || echo "  ‚ùå Uvicorn NOT started"
          echo ""
          
          # Check for errors
          echo "‚ùå Error Detection:"
          if grep -qi "error" server.log; then
            echo "  ‚ö†Ô∏è  Found error messages:"
            grep -i "error" server.log | head -n 10
          else
            echo "  ‚úÖ No error messages found"
          fi
          echo ""
          
          if grep -qi "traceback" server.log; then
            echo "  ‚ö†Ô∏è  Found tracebacks:"
            grep -A 20 -i "traceback" server.log | head -n 50
          else
            echo "  ‚úÖ No tracebacks found"
          fi
          echo ""
          
          if grep -qi "ModuleNotFoundError" server.log; then
            echo "  ‚ùå ModuleNotFoundError detected:"
            grep -B 3 -A 10 "ModuleNotFoundError" server.log
            exit 1
          else
            echo "  ‚úÖ No ModuleNotFoundError"
          fi
          echo ""
          
          if grep -qi "ImportError" server.log; then
            echo "  ‚ùå ImportError detected:"
            grep -B 3 -A 10 "ImportError" server.log
            exit 1
          else
            echo "  ‚úÖ No ImportError"
          fi
          echo ""
          
          if grep -qi "exit code: 1" server.log; then
            echo "  ‚ùå Exit code 1 detected!"
            grep -B 10 -A 5 "exit code: 1" server.log
          else
            echo "  ‚úÖ No exit code 1 found"
          fi
      
      - name: üè• Attempt health check
        if: steps.check_process.outputs.status == 'running'
        continue-on-error: true
        run: |
          echo "===================================="
          echo "üè• Health Check Attempt"
          echo "===================================="
          
          # Give server more time to bind
          echo "Waiting 3 seconds for port binding..."
          sleep 3
          
          echo ""
          echo "Checking port 8000..."
          if netstat -tln 2>/dev/null | grep -q ":8000 "; then
            echo "‚úÖ Port 8000 is listening"
          else
            echo "‚ö†Ô∏è  Port 8000 not found in netstat"
          fi
          
          echo ""
          echo "Attempting HTTP connection..."
          
          # Try root endpoint
          if timeout 5 curl -f -s http://localhost:8000/ > /tmp/root_response 2>&1; then
            echo "‚úÖ Server responding on root /"
            echo "Response:"
            cat /tmp/root_response
          else
            echo "‚ö†Ô∏è  No response from root / (this may be expected for MCP servers)"
          fi
          
          echo ""
          # Try MCP endpoint  
          if timeout 5 curl -f -s http://localhost:8000/mcp > /tmp/mcp_response 2>&1; then
            echo "‚úÖ Server responding on /mcp"
            echo "Response:"
            cat /tmp/mcp_response
          else
            echo "‚ö†Ô∏è  No response from /mcp endpoint"
          fi
      
      - name: üìà Show process info
        if: always()
        run: |
          cd vm_server
          if [ -f server.pid ]; then
            SERVER_PID=$(cat server.pid)
            echo "===================================="
            echo "üìä Process Information"
            echo "===================================="
            echo "PID: $SERVER_PID"
            echo ""
            ps aux | head -1
            ps aux | grep $SERVER_PID | grep -v grep || echo "Process not found (already exited)"
            echo ""
            
            # Show any remaining python processes
            echo "Other Python processes:"
            ps aux | grep python | grep -v grep || echo "None"
          fi
      
      - name: üßπ Cleanup - Stop server
        if: always()
        run: |
          cd vm_server
          if [ -f server.pid ]; then
            SERVER_PID=$(cat server.pid)
            echo "===================================="
            echo "üßπ Cleanup"
            echo "===================================="
            echo "Stopping server PID: $SERVER_PID"
            
            if ps -p $SERVER_PID > /dev/null 2>&1; then
              echo "Sending SIGTERM..."
              kill $SERVER_PID 2>/dev/null || true
              sleep 2
              
              if ps -p $SERVER_PID > /dev/null 2>&1; then
                echo "Process still alive, sending SIGKILL..."
                kill -9 $SERVER_PID 2>/dev/null || true
                sleep 1
              fi
              
              if ps -p $SERVER_PID > /dev/null 2>&1; then
                echo "‚ö†Ô∏è  Process still running!"
              else
                echo "‚úÖ Process terminated"
              fi
            else
              echo "Process already stopped"
            fi
            
            echo "‚úÖ Cleanup complete"
          fi
      
      - name: üì§ Upload server logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: server-logs-python-${{ matrix.python-version }}
          path: |
            vm_server/server.log
            vm_server/start_server.sh
          retention-days: 7

  summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: test-server-startup
    if: always()
    steps:
      - name: üìä Generate test summary
        run: |
          echo "# üß™ Server Startup Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Branch: debug-hardcoded-secrets" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This workflow tests server startup with MAXIMUM DEBUG OUTPUT:" >> $GITHUB_STEP_SUMMARY
          echo "- üîç Python -u (unbuffered) and -v (verbose imports) flags" >> $GITHUB_STEP_SUMMARY
          echo "- üìä Complete stdout/stderr capture" >> $GITHUB_STEP_SUMMARY
          echo "- ‚è±Ô∏è Timing information at every step" >> $GITHUB_STEP_SUMMARY
          echo "- üêõ Detailed error tracebacks" >> $GITHUB_STEP_SUMMARY
          echo "- üìà Process status monitoring" >> $GITHUB_STEP_SUMMARY
          echo "- üéØ Startup milestone tracking" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Expected Behavior" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Success:**" >> $GITHUB_STEP_SUMMARY
          echo "- Server process starts and stays running" >> $GITHUB_STEP_SUMMARY
          echo "- All startup milestones reached" >> $GITHUB_STEP_SUMMARY
          echo "- No ModuleNotFoundError or ImportError" >> $GITHUB_STEP_SUMMARY
          echo "- Uvicorn starts successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ùå **Failure:**" >> $GITHUB_STEP_SUMMARY
          echo "- Download server logs to see EXACT failure point" >> $GITHUB_STEP_SUMMARY
          echo "- Check 'Log Analysis' step for milestone progress" >> $GITHUB_STEP_SUMMARY
          echo "- Review complete traceback in logs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üì• **Artifacts contain:**" >> $GITHUB_STEP_SUMMARY
          echo "- server.log: Complete server output with all debug info" >> $GITHUB_STEP_SUMMARY
          echo "- start_server.sh: Wrapper script used to launch server" >> $GITHUB_STEP_SUMMARY
